// set domains
domain Player = x | o
domain Score = 50 | 0 | 100
domain Boolean = true | false

domain Position = P(X, Y) where X in 0..2, Y in 0..2
// big board
domain GlobalPiece = empty | x | o | tie
// small boards
domain LocalPiece = empty | x | o


// set all local boards to empty
game_board : Position -> Position -> LocalPiece = {
  P(GX, GY) = {
    P(X, Y) = empty
    where X in 0..2, Y in 0..2
  }
  where GX in 0..2, GY in 0..2, X in 0..2, Y in 0..2 
}

global_board : Position -> GlobalPiece = { 
  P(GX, GY) = empty 
  where GX in 0..2, GY in 0..2
}

// helper 'functions'
next_d1 : Position -> Position
next_d1(P(X, Y)) = if X == Y then P((X + 1) % 3, (Y + 1) % 3) else P(X, Y)

next_d2 : Position -> Position
next_d2(P(X, Y)) = if X + Y == 2 then P((X + 1) % 3, (Y - 1) % 3) else P(X, Y)

next_h : Position -> Position
next_h(P(X, Y)) = P(X, (Y + 1) % 3)

next_v : Position -> Position
next_v(P(X, Y)) = P((X + 1) % 3, Y)


op : Player -> Player
op(x) = o
op(o) = x


position_global_active : Boolean
position_global : Position
position_local : Position

graph local_findNonempty() {
  forall p:Position {
    check(game_board[position_global][p] == empty)
  }
}
graph global_findNonempty() {
  forall p:Position {
    check(global_board[position_global] == empty)
  }
}

graph global_win() {
  branch {
    check(position_global != next_d1(position_global))
    check(global_board[position_global] == global_board[next_d1(position_global)])
    check(global_board[position_global] == global_board[next_d1(next_d1(position_global))])
  } or {
    check(position_global != next_d2(position_global))
    check(global_board[position_global] == global_board[next_d2(position_global)])
    check(global_board[position_global] == global_board[next_d2(next_d2(position_global))])
  } or {
    check(global_board[position_global] == global_board[next_h(position_global)])
    check(global_board[position_global] == global_board[next_h(next_h(position_global))])
  } or {
    check(global_board[position_global] == global_board[next_v(position_global)])
    check(global_board[position_global] == global_board[next_v(next_v(position_global))])
  }
}
graph local_win() {
  branch {
    check(position_local != next_d1(position_local))
    check(game_board[position_local] == game_board[next_d1(position_local)])
    check(game_board[position_local] == game_board[next_d1(next_d1(position_local))])
  } or {
    check(position_local != next_d2(position_local))
    check(game_board[position_local] == game_board[next_d2(position_local)])
    check(game_board[position_local] == game_board[next_d2(next_d2(position_local))])
  } or {
    check(game_board[position_local] == game_board[next_h(position_local)])
    check(game_board[position_local] == game_board[next_h(next_h(position_local))])
  } or {
    check(game_board[position_local] == game_board[next_v(position_local)])
    check(game_board[position_local] == game_board[next_v(next_v(position_local))])
  }
}

graph turn(me: Player) {
  player = me
  
  if position_global_active == false {
    forall gp:Position {
      check(global_board[gp] == empty)
      
      forall p:Position {
        check(game_board[gp][p] == empty)
        // update board
        game_board[gp][p] = me
        position_global = gp  // not sure how this works, so...
        position_local = p
        position_global_active = true

        // branch? or do something
        $ p
      }

      $ gp
    }
  } 
  if position_global_active == true {
    forall p:Position {
      check(game_board[gp][p] == empty)
      game_board[gp][p] = me
      position_local = p
      $ p
    }
  }


  player = keeper
  
  if reachable(local_win()) {
    global_board[position_global] = me
    position_global = position_local
  }
  if reachable(global_win()) {
    goals[me] = 100
    goals[op[me]] = 0
    end()
  }

  if not(reachable(local_findNonempty())) {
    global_board[position_global] = tie
  }
  if not(reachable(global_findNonempty())) {
    end()
  }
 
  position_global = position_local
  if global_board[position_global] != empty {
    position_global_active = false
  }
}

graph rules() {
  loop {
    turn(x)
    turn(o)
  }
}
