// set domains
domain Player = x | o
domain Score = 50 | 0 | 100
domain Boolean = true | false

domain Position = P(X, Y) where X in 0..2, Y in 0..2
// big board
domain GlobalPiece = empty | x | o | tie
// small boards
domain LocalPiece = empty | x | o
// for double loop
domain DoublePosition = DP(X1, Y1, X2, Y2) 
  where X1 in 0..2, Y1 in 0..2, X2 in 0..2, Y2 in 0..2 


// set all local boards to empty
game_board : Position -> Position -> LocalPiece = {
  P(GX, GY) = {
    P(X, Y) = empty
    where X in 0..2, Y in 0..2
  }
  where GX in 0..2, GY in 0..2, X in 0..2, Y in 0..2 
}

global_board : Position -> GlobalPiece = { 
  P(GX, GY) = empty 
  where GX in 0..2, GY in 0..2
}

// helper 'functions'
next_d1 : Position -> Position
next_d1(P(X, Y)) = if X == Y then P((X + 1) % 3, (Y + 1) % 3) else P(X, Y)

next_d2 : Position -> Position
next_d2(P(X, Y)) = if X + Y == 2 then P((X + 1) % 3, (Y - 1) % 3) else P(X, Y)

next_h : Position -> Position
next_h(P(X, Y)) = P(X, (Y + 1) % 3)

next_v : Position -> Position
next_v(P(X, Y)) = P((X + 1) % 3, Y)


op : Player -> Player
op(x) = o
op(o) = x


dp_extract : Boolean -> DoublePosition -> Position
dp_extract(FIRST, DP(X1, Y1, X2, Y2)) = 
  if FIRST == true then P(X1, Y1)
  else P(X2, Y2)


position_global_active : Boolean
position_global : Position
position_local : Position

graph findNonempty(board: Position -> GlobalPiece) {
  forall p:Position {
    check(board[p] == empty)
  }
}

graph win(board: Position -> GlobalPiece, position: Position) {
  branch {
    check(position != next_d1(position))
    check(board[position] == board[next_d1(position)])
    check(board[position] == board[next_d1(next_d1(position))])
  } or {
    check(position != next_d2(position))
    check(board[position] == board[next_d2(position)])
    check(board[position] == board[next_d2(next_d2(position))])
  } or {
    check(board[position] == board[next_h(position)])
    check(board[position] == board[next_h(next_h(position))])
  } or {
    check(board[position] == board[next_v(position)])
    check(board[position] == board[next_v(next_v(position))])
  }
}


graph turn(me: Player) {
  player = me
  
  // forall gp:Position {      // TODO adding this loop breaks everything
  //   check(global_board[gp] == empty)

    // forall p:Position {
    //   check(game_board[gp][p] == empty)
    //   // update board
    //   game_board[gp][p] = me
    //   position_global = gp
    //   position_local = p
    //   position_global_active = true

    //   $ p
    // }

  //   $ gp
  // }
  
  // TODO: use position_global_active
  forall dp:DoublePosition {
    // ensure we can play in given board
    check(global_board[dp_extract(true, dp)] == empty)
    // ensure that chosen cell is empty
    check(game_board[dp_extract(true, dp)][dp_extract(false, dp)] == empty)

    // TODO: can i assign this before checks?
    position_global = dp_extract(true, dp)
    position_local = dp_extract(false, dp)
    position_global_active = true
    game_board[position_global][position_local] = me

    $ dp
  }


  player = keeper

  if reachable(win(game_board[position_global], position_local)) {
    global_board[position_global] = me
    position_global = position_local

    if reachable(win(global_board, position_global)) {
      goals[me] = 100
      goals[op[me]] = 0
      end()
    }

    end() //DEB
  }


  if not(reachable(findNonempty(game_board[position_global]))) {
    global_board[position_global] = tie
    end() //DEB
  }
  if not(reachable(findNonempty(global_board))) {
    end()
  }

  position_global = position_local
  if global_board[position_global] != empty {
    position_global_active = false
  }
}

graph rules() {
  loop {
    turn(x)
    turn(o)
  }
}
