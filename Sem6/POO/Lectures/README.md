[(back)](../)

- [Wykład 1 - Unified Process](#wykład-1---unified-process)
  - [1. Unified Process (UP)](#1-unified-process-up)
  - [2. Faza Rozpoczęcia (Business Modelling)](#2-faza-rozpoczęcia-business-modelling)
  - [3. Zbieranie Wymagań (Requirements)](#3-zbieranie-wymagań-requirements)
    - [3.1 FURPS+](#31-furps)
    - [3.2 S.M.A.R.T.](#32-smart)
  - [4. Przypadki Użycia (Use Cases)](#4-przypadki-użycia-use-cases)
    - [Przykład w Gherkin (Cucumber):](#przykład-w-gherkin-cucumber)
- [Wykład 2 - UML](#wykład-2---uml)
  - [1. Wprowadzenie do UML](#1-wprowadzenie-do-uml)
  - [2. Diagramy Klas (Class Diagram)](#2-diagramy-klas-class-diagram)
    - [2.1 Hierarchia modeli](#21-hierarchia-modeli)
    - [2.2 Strategie mapowania dziedziczenia na tabele](#22-strategie-mapowania-dziedziczenia-na-tabele)
    - [2.3 Kluczowe pojęcia](#23-kluczowe-pojęcia)
  - [3. Diagramy Obiektów (Object Diagram)](#3-diagramy-obiektów-object-diagram)
  - [4. Diagramy Stanów (State Diagram)](#4-diagramy-stanów-state-diagram)
  - [5. Diagramy Czynności (Activity Diagram)](#5-diagramy-czynności-activity-diagram)
  - [6. Diagramy Sekwencji (Sequence Diagram)](#6-diagramy-sekwencji-sequence-diagram)
  - [7. Diagramy Komponentów (Component Diagram)](#7-diagramy-komponentów-component-diagram)
  - [8. Diagrams-as-Code](#8-diagrams-as-code)
- [Wykład 3 - SOLID GRASP](#wykład-3---solid-grasp)
  - [1. Responsibility-Driven Development (RDD)](#1-responsibility-driven-development-rdd)
  - [2. GRASP (General Responsibility Assignment Software Patterns)](#2-grasp-general-responsibility-assignment-software-patterns)
  - [3. SOLID – Pięć kluczowych zasad obiektowych](#3-solid--pięć-kluczowych-zasad-obiektowych)
  - [4. Inne zasady](#4-inne-zasady)
- [Wykład 4: Wzorce Projektowe (Podstawowe i Kreacyjne)](#wykład-4-wzorce-projektowe-podstawowe-i-kreacyjne)
  - [1. Wzorce Podstawowe](#1-wzorce-podstawowe)
    - [1.1 Interfejs vs Klasa Abstrakcyjna](#11-interfejs-vs-klasa-abstrakcyjna)
    - [1.2 Delegacja (Preferuj Delegację nad Dziedziczeniem)](#12-delegacja-preferuj-delegację-nad-dziedziczeniem)
  - [2. Wzorce Kreacyjne](#2-wzorce-kreacyjne)
    - [2.1 Singleton](#21-singleton)
    - [2.2 Monostate](#22-monostate)
    - [2.3 Fabryka (Delegate Factory)](#23-fabryka-delegate-factory)
    - [2.4 Factory Method](#24-factory-method)
    - [2.5 Abstract Factory](#25-abstract-factory)
    - [2.6 Prototype](#26-prototype)
    - [2.7 Object Pool](#27-object-pool)
    - [2.8 Builder](#28-builder)
- [Wykład 5: Wzorce Strukturalne](#wykład-5-wzorce-strukturalne)
  - [1. Fasada (Facade)](#1-fasada-facade)

# Wykład 1 - Unified Process
<!-- generated by aiaiai -->
## 1. Unified Process (UP)
- **Definicja**: Rama organizacji procesu wytwarzania oprogramowania z wyodrębnionymi fazami:  
  _inicjowanie, projektowanie, implementacja, testowanie, wdrażanie_.  
- **Iteracyjny rozwój**: Dostarczanie wartości biznesowej w iteracjach ograniczonych czasowo.  
- **Fazy UP**:  
  | Inicjowanie (Inception) | Rozwinięcie (Elaboration) | Konstrukcja (Construction) | Przejście (Transition) |  
  |-------------------------|----------------------------|-----------------------------|-------------------------|  
  | Modelowanie biznesowe   | E1, E2                     | C1-C4                       | T1, T2                 |  

## 2. Faza Rozpoczęcia (Business Modelling)
- **Cel**: Określenie zakresu, wizji i uwarunkowań biznesowych.  
- **Typowe artefakty**:  
  - Wizja i analiza biznesowa  
  - Słowniczek terminów  
  - Prototyp (weryfikacja rozwiązań technicznych)  
  - Plan pierwszej iteracji  
  - Specyfikacja dodatkowa  
  - Plan zarządzania ryzykiem  

## 3. Zbieranie Wymagań (Requirements)
### 3.1 FURPS+  
- **Obszary wymagań**:  
  | Kategoria          | Opis                                  |  
  |--------------------|---------------------------------------|  
  | Functional         | Funkcjonalności, bezpieczeństwo       |  
  | Usability          | Ergonomia, dokumentacja               |  
  | Reliability        | Odporność na awarie                   |  
  | Performance        | Wydajność, dostępność                 |  
  | Supportability     | Utrzymanie, konfiguracja              |  
  | Design             | Ograniczenia projektowe               |  
  | Implementation     | Narzędzia, standardy                  |  

- **Typowe problemy**:  
  1. Brak priorytetyzacji wymagań.  
  2. Wymagania niemierzalne lub niejasne.  
  3. Przykłady wymagań prawnych: RODO, WCAG 2.0.  

### 3.2 S.M.A.R.T.  
- **Kryteria oceny wymagań**:  
  - **S**zczegółowy  
  - **M**ierzalny  
  - **A**trakcyjny (osiągalny)  
  - **R**ealistyczny  
  - **T**erminowy  

**Przykład wymagania SMART**:  
> Średni czas odpowiedzi przy transakcjach bez zapisu nie może przekraczać **5 sekund**.  

---

## 4. Przypadki Użycia (Use Cases)
- **Definicja**: Sekwencja kroków opisująca interakcję między aktorem a systemem.  
- **Rodzaje dokumentacji**:  
  - **Nieformalna (brief)**: Krótki opis głównego scenariusza sukcesu.  
  - **Pełna (fully dressed)**: Wszystkie kroki, warianty, warunki początkowe/końcowe.  

### Przykład w Gherkin (Cucumber):  
```gherkin
Feature: Zarządzanie kontrahentami  
  Scenario: Dodawanie kontrahenta  
    Given: Jestem zalogowany jako ADMIN  
    When: Dodaję kontrahenta z poprawnymi danymi  
    Then: System rejestruje kontrahenta  
```




# Wykład 2 - UML
<!-- again - aiaiai -->
## 1. Wprowadzenie do UML
- **Rodzaje diagramów**:  
  - **Strukturalne** (np. diagram klas, komponentów) – dokumentują statyczne elementy systemu.  
  - **Behawioralne** (np. diagram sekwencji, stanów) – dokumentują dynamikę systemu.  
- **Narzędzia**:  
  - draw.io, yuml.me (lekkie), Enterprise Architect, Visual Paradigm (zaawansowane).  

---

## 2. Diagramy Klas (Class Diagram)

### 2.1 Hierarchia modeli
| Typ modelu      | Opis                                                        | Przykłady elementów                                 |
|-----------------|-------------------------------------------------------------|-----------------------------------------------------|
| **Pojęciowy**   | Reprezentuje pojęcia i relacje w dziedzinie.                | Pojęcia, asocjacje (bez metod).                     |
| **Obiektowy**   | Refaktoryzacja modelu pojęciowego na klasy obiektowe.       | Klasy, metody, relacje (agregacja, dziedziczenie).  |
| **Relacyjny**   | Mapowanie klas na tabele w bazie danych.                    | Tabele, klucze obce, strategie mapowania dziedziczenia. |

### 2.2 Strategie mapowania dziedziczenia na tabele
| Strategia               | Opis                                                                 | Przykład                                         |
|-------------------------|----------------------------------------------------------------------|--------------------------------------------------|
| **Table per concrete**  | Każda klasa potomna ma własną tabelę.                               | `Footballer`, `Cricketer` – osobne tabele.       |
| **Table per hierarchy** | Wszystkie klasy w jednej tabeli z kolumną dyskryminującą.           | Kolumna `type` w tabeli `Players`.               |
| **Table per type**      | Tabela dla klasy bazowej + tabele dla klas potomnych z relacjami.   | Tabela `Players` + `Footballers`, `Cricketers`.  |

### 2.3 Kluczowe pojęcia
- **Agregacja vs kompozycja**:  
  - **Agregacja** (pusta kreska): Część może istnieć niezależnie od całości.  
  - **Kompozycja** (wypełniony romb): Część jest ściśle powiązana z całością (np. cykl życia).  
- **Liczebność**: `1`, `*`, `0..1`, `1..*`.  
- **Klasa asocjacyjna**: Używana do modelowania relacji wiele-wiele z dodatkowymi atrybutami.  

---

## 3. Diagramy Obiektów (Object Diagram)
- **Cel**: Migawka stanu systemu w konkretnym momencie.  
- **Elementy**: Instancje klas (obiekty) z wartościami atrybutów i powiązaniami.  
- **Przykład**:
  ```plaintext
  obiekt1: Osoba
    imię = "Jan"
    nazwisko = "Kowalski"
  obiekt2: Samochód
    model = "Tesla"
  obiekt1 -- obiekt2 : posiada
  ```

---

## 4. Diagramy Stanów (State Diagram)
- **Cel**: Modelowanie maszyn stanowych.
- **Elementy**:
  - **Stany**: Bloczki (np. Oczekiwanie, Przetwarzanie).
  - **Przejścia**: Strzałki z warunkami/akcjami (np. `[zatwierdzone] -> Zakończ`).
- **Przykład**:
  ```plaintext
  [Start] --> Oczekiwanie
  Oczekiwanie --> Przetwarzanie : [zdarzenie]
  Przetwarzanie --> Zakończ : [sukces]
  ```

---

## 5. Diagramy Czynności (Activity Diagram)
- **Cel**: Dokumentacja procesów biznesowych lub algorytmów.
- **Elementy**:
  - **Czynności**: Długotrwałe kroki (np. Przetwórz zamówienie).
  - **Akcje**: Krótkie operacje (np. Sprawdź dostępność).
  - **Partycje**: Podział na role (np. Klient, System).
- **Różnica od diagramu sekwencji**: Brak jednoznacznej osi czasu – skupia się na przepływie kroków.

---

## 6. Diagramy Sekwencji (Sequence Diagram)
- **Cel**: Pokazanie interakcji między obiektami w czasie.
- **Elementy**:
  - **Linie życia**: Reprezentują obiekty (np. `:Klient`, `:System`).
  - **Komunikaty**: Strzałki z opisem (np. `wyślijZamówienie()`).
  - **Ramki**: Obszary warunkowe (np. `loop`, `alt`).
- **Przykład**:
  ```plaintext
  Klient -> System : wyślijZamówienie()
  System -> BazaDanych : sprawdźDostępność()
  BazaDanych --> System : dostępność=true
  System --> Klient : potwierdźZamówienie()
  ```

---

## 7. Diagramy Komponentów (Component Diagram)
- **Cel**: Modelowanie struktury systemu z komponentami i ich zależnościami.
- **Elementy**:
  - **Komponenty**: Moduły (np. Serwer, Baza Danych).
  - **Porty**: Punkty interakcji (np. `dostawca_danych`, `odbiorca_danych`).
- **Przykład**:
  ```plaintext
  [Komponent A] --(port1)--> [Komponent B]
  ```

---

## 8. Diagrams-as-Code
- **Narzędzia**: PlantUML, Mermaid.js – generują diagramy z tekstu.
- **Zalety**: Łatwa integracja z repozytoriami kodu.
- **Przykład (Mermaid)**:
  ```mermaid
  classDiagram
    class Samochod
    class Kierownik
    Samochod "1" -- "1..*" Kierownik : zarządza
  ```


# Wykład 3 - SOLID GRASP
## 1. Responsibility-Driven Development (RDD)
Projektowanie obiektowe polega na przypisaniu odpowiedzialności klasom i określeniu ich relacji. Skrajności:
- **Jedna ogromna klasa** – wszystko w jednej strukturze.
- **Bardzo dużo klas, każda z jedną metodą** – nadmierna fragmentacja.

## 2. GRASP (General Responsibility Assignment Software Patterns)
Zbiór dobrych praktyk dotyczących podziału odpowiedzialności:  
1. **Creator** – klasa B tworzy instancje A, jeśli je zawiera, przechowuje lub używa.  
2. **Information Expert** – klasa posiadająca niezbędne dane powinna realizować operację.  
3. **Controller** – odbiera żądania systemowe (np. `Handler`, `Controller`).  
4. **Low Coupling** – minimalizacja powiązań między klasami.  
5. **High Cohesion** – każda klasa powinna mieć jedno, dobrze określone zadanie.  
6. **Polymorphism** – eliminacja instrukcji `if` zależnych od typu poprzez polimorfizm.  
7. **Indirection** – dodatkowa warstwa pośrednicząca dla zmniejszenia sprzężenia.  
8. **Pure Fabrication** – sztuczne klasy pomocnicze poprawiające strukturę (np. `Repository`).  
9. **Protected Variations (Law of Demeter)** – interfejsy stabilizujące punkty zmienności.

## 3. SOLID – Pięć kluczowych zasad obiektowych
1. **SRP (Single Responsibility Principle)** – klasa powinna mieć jedną odpowiedzialność.  
2. **OCP (Open-Closed Principle)** – kod powinien być otwarty na rozszerzenia, ale zamknięty na modyfikacje.  
3. **LSP (Liskov Substitution Principle)** – obiekty klasy bazowej powinny być zastępowalne przez klasy pochodne bez zmiany zachowania.  
4. **ISP (Interface Segregation Principle)** – interfejsy powinny być podzielone na mniejsze, aby klasy nie implementowały nieużywanych metod.  
5. **DIP (Dependency Inversion Principle)** – moduły wyższego poziomu powinny zależeć od abstrakcji, a nie implementacji.

## 4. Inne zasady
- **DRY (Don’t Repeat Yourself)** – unikanie powielania kodu.  
- **LoD (Law of Demeter)** – ograniczenie wiedzy klasy o innych klasach.  
- **DMMT (Don’t Make Me Think)** – przejrzystość kodu.  
- **DOP (Don’t Optimize Prematurely)** – unikanie przedwczesnej optymalizacji.


# Wykład 4: Wzorce Projektowe (Podstawowe i Kreacyjne)

## 1. Wzorce Podstawowe

### 1.1 Interfejs vs Klasa Abstrakcyjna
- **Interfejs**:
  - Tylko deklaracje metod (brak implementacji)
  - Klasa może implementować wiele interfejsów
- **Klasa abstrakcyjna**:
  - Może zawierać częściową implementację
  - Klasa dziedziczy tylko z jednej klasy abstrakcyjnej
- **Przykład**: `IEnumerable` (interfejs) vs `Stream` (klasa abstrakcyjna)

### 1.2 Delegacja (Preferuj Delegację nad Dziedziczeniem)
- **Zalety**:
  - Dynamiczna zmiana zachowania (wymiana delegata w runtime)
  - Unika problemów dziedziczenia (np. krucha klasa bazowa)
- **Wady**:
  - Więcej kodu (ręczne przekazywanie wywołań)
  - Brak wsparcia składniowego w językach jak C#
- **Zasada**: "Faworyzuj kompozycję nad dziedziczeniem"

---

## 2. Wzorce Kreacyjne

### 2.1 Singleton
- **Cel**: Jedna instancja klasy, globalny dostęp
- **Implementacja**:
  ```csharp
  public class Singleton {
      private static Singleton _instance;
      private Singleton() {}
      public static Singleton Instance => _instance ??= new Singleton();
  }
  ```

- **Rozszerzenia**: Leniwa inicjalizacja, kontrola czasu życia (np. za pomocą DI)

### 2.2 Monostate
Cel: Wiele instancji, ale współdzielony stan (np. statyczne pola)

Różnica od Singleton: Nie ogranicza liczby instancji, tylko stan jest współdzielony

### 2.3 Fabryka (Delegate Factory)
Cel: Enkapsulacja logiki tworzenia obiektów

Zalety:

Spełnia zasadę Open/Closed (łatwe dodawanie nowych typów)

Kontrola cyklu życia obiektów (np. zwracanie istniejących instancji)

Przykład:

```csharp
public interface IProduct {}
public class ProductA : IProduct {}

public class ProductFactory {
    public IProduct CreateProduct() => new ProductA();
}
```

### 2.4 Factory Method
Cel: Delegowanie tworzenia obiektów do podklas

Struktura:

```csharp
public abstract class Creator {
    public abstract IProduct FactoryMethod();
    public void Operation() => FactoryMethod().DoSomething();
}

public class ConcreteCreator : Creator {
    public override IProduct FactoryMethod() => new ConcreteProduct();
}
```

### 2.5 Abstract Factory
Cel: Tworzenie rodzin powiązanych obiektów (np. elementy GUI dla Windows/Mac)

Struktura:

```csharp
public interface IAbstractFactory {
    IButton CreateButton();
    ITextBox CreateTextBox();
}

public class WindowsFactory : IAbstractFactory { ... }
public class MacFactory : IAbstractFactory { ... }
```

### 2.6 Prototype

Cel: Tworzenie obiektów przez klonowanie prototypów

Implementacja: Interfejs ICloneable lub metoda Clone()

Zastosowanie: Gdy tworzenie obiektu jest kosztowne (np. głęboka kopia)

### 2.7 Object Pool
Cel: Reużywanie kosztownych obiektów (np. połączenia bazodanowe)

Implementacja:

```csharp
public class ObjectPool {
    private readonly Queue<Reusable> _pool = new();
    
    public Reusable Acquire() {
        return _pool.Count > 0 ? _pool.Dequeue() : new Reusable();
    }
    
    public void Release(Reusable obj) {
        _pool.Enqueue(obj);
    }
}
```

Testy: Walidacja rozmiaru puli, pobieranie/zwracanie obiektów

### 2.8 Builder
Cel: Konstrukcja złożonych obiektów krok po kroku

Elementy:

Builder: Interfejs z metodami budowania części

ConcreteBuilder: Implementacja budowniczego

Director: Koordynuje proces budowy

Product: Wynikowy obiekt

Przykład: Fluent API (np. StringBuilder)

```csharp
var builder = new HtmlBuilder();
builder.AddTag("div").AddClass("container").SetContent("Hello");
```

# Wykład 5: Wzorce Strukturalne

## 1. Fasada (Facade)
- **Cel**: Uproszczony interfejs dla złożonego podsystemu  
- **Zastosowanie**: Ukrywa złożoność systemu, udostępniając klientowi jeden uproszczony punkt dostępu  
- **Przykład**:  
  ```csharp
  public class SmtpFacade {
      public void Send(string From, string To, string Subject, 
                      string Body, Stream Attachment, string AttachmentMimeType) {
          // Kompleksowa logika wysyłki maila ukryta za fasadą
      }
  }
  ```

2. Interfejs Tylko-do-Odczytu (Read-only Interface)
Cel: Ograniczenie dostępu do modyfikacji stanu obiektu

Zastosowanie: Bezpieczne udostępnianie obiektów wielu klientom

Implementacja:

plaintext
[ReadOnlyInterface] ---> [Pełny interfejs z get/set]
        ↑                      ↑
[Klient tylko do odczytu]  [Klient z uprawnieniami do zapisu]
Przykład: ReadOnlyCollection w .NET (AsReadOnly())

3. Pyłek (Flyweight)
Cel: Efektywne zarządzanie wieloma drobnymi obiektami

Kluczowe koncepcje:

Stan wewnętrzny (intrinsic): Współdzielony (np. kolor bierki)

Stan zewnętrzny (extrinsic): Unikalny (np. pozycja X/Y)

Przykład (Plansza do warcabów):

csharp
public class Board {
    private Dictionary<PieceColor, Piece> _pieces = new();
    
    public Piece GetPiece(int x, int y) {
        PieceColor key = (x + y) % 2 == 0 ? PieceColor.White : PieceColor.Black;
        if (!_pieces.ContainsKey(key)) 
            _pieces.Add(key, new Piece { Color = key });
        return _pieces[key];
    }
}
4. Dekorator (Decorator)
Cel: Dynamiczne rozszerzanie funkcjonalności obiektów

Zastosowanie: Alternatywa dla dziedziczenia, szczególnie w strumieniach danych

Przykład (Dodatki do napojów):

csharp
public class SugarDecorator : IDrink {
    private IDrink _drink;
    public SugarDecorator(IDrink drink) => _drink = drink;
    
    public decimal Cost => _drink.Cost + 1;
    public string Name => _drink.Name + " with sugar";
}
// Użycie:
IDrink tea = new SugarDecorator(new SugarDecorator(new Tea()));
5. Pełnomocnik (Proxy)
Typy:

Wirtualny: Tworzy obiekt na żądanie (Lazy<T>)

Ochronny: Kontrola dostępu

Zdalny: Reprezentacja obiektu w innej domenie

Logujący: Rejestracja dostępu

Circuit Breaker: Specjalny typ proxy do obsługi błędów:

plaintext
[Zamknięty] → (błąd) → [Otwarty] → (timeout) → [Półotwarty]
    ↑______________________(sukces)___________________↓
Biblioteki: Polly (.NET), resilience4j (Java)

6. Adapter
Cel: Uzgadnianie niezgodnych interfejsów

Struktura:

plaintext
[Klient] → [Target] ← (adaptuje) ← [Adapter] → [Adaptee]
Zastosowanie: Integracja starszych systemów z nowymi komponentami

7. Most (Bridge)
Cel: Oddzielenie abstrakcji od implementacji

Zastosowanie: Niezależne rozwijanie hierarchii funkcjonalności

Przykład (Rejestr osób):

csharp
public abstract class AbstractPersonRegistry {
    public IMessenger messenger; // Implementacja wyniesiona
    public abstract void LoadPersons(); // Abstrakcja
    public void NotifyPersons() => /* ... używa messenger ... */
}
public interface IMessenger { void Notify(Person p); }
Literatura:

Gamma i in. - Wzorce projektowe

Martin i Martin - Zasady, wzorce i praktyki zwinnego wytwarzania...

Freeman i in. - Head First Design Patterns

OODesign.com