[(back)](../)

# Wykłady
- [Wykłady](#wykłady)
  - [Wykład 1 - Unified Process](#wykład-1---unified-process)
  - [1. Unified Process (UP)](#1-unified-process-up)
  - [2. Faza Rozpoczęcia (Business Modelling)](#2-faza-rozpoczęcia-business-modelling)
  - [3. Zbieranie Wymagań (Requirements)](#3-zbieranie-wymagań-requirements)
    - [3.1 FURPS+](#31-furps)
    - [3.2 S.M.A.R.T.](#32-smart)
  - [4. Przypadki Użycia (Use Cases)](#4-przypadki-użycia-use-cases)
    - [Przykład w Gherkin (Cucumber):](#przykład-w-gherkin-cucumber)
  - [Wykład 2 - UML](#wykład-2---uml)
  - [1. Wprowadzenie do UML](#1-wprowadzenie-do-uml)
  - [2. Diagramy Klas (Class Diagram)](#2-diagramy-klas-class-diagram)
    - [2.1 Hierarchia modeli](#21-hierarchia-modeli)
    - [2.2 Strategie mapowania dziedziczenia na tabele](#22-strategie-mapowania-dziedziczenia-na-tabele)
    - [2.3 Kluczowe pojęcia](#23-kluczowe-pojęcia)
  - [3. Diagramy Obiektów (Object Diagram)](#3-diagramy-obiektów-object-diagram)
  - [Wykład 3 - SOLID GRASP](#wykład-3---solid-grasp)
  - [**1. Responsibility-Driven Development (RDD)**](#1-responsibility-driven-development-rdd)
  - [**2. GRASP (General Responsibility Assignment Software Patterns)**](#2-grasp-general-responsibility-assignment-software-patterns)
  - [**3. SOLID – Pięć kluczowych zasad obiektowych**](#3-solid--pięć-kluczowych-zasad-obiektowych)
  - [**4. Inne zasady**](#4-inne-zasady)

## Wykład 1 - Unified Process
<!-- generated by aiaiai -->
## 1. Unified Process (UP)
- **Definicja**: Rama organizacji procesu wytwarzania oprogramowania z wyodrębnionymi fazami:  
  _inicjowanie, projektowanie, implementacja, testowanie, wdrażanie_.  
- **Iteracyjny rozwój**: Dostarczanie wartości biznesowej w iteracjach ograniczonych czasowo.  
- **Fazy UP**:  
  | Inicjowanie (Inception) | Rozwinięcie (Elaboration) | Konstrukcja (Construction) | Przejście (Transition) |  
  |-------------------------|----------------------------|-----------------------------|-------------------------|  
  | Modelowanie biznesowe   | E1, E2                     | C1-C4                       | T1, T2                 |  

## 2. Faza Rozpoczęcia (Business Modelling)
- **Cel**: Określenie zakresu, wizji i uwarunkowań biznesowych.  
- **Typowe artefakty**:  
  - Wizja i analiza biznesowa  
  - Słowniczek terminów  
  - Prototyp (weryfikacja rozwiązań technicznych)  
  - Plan pierwszej iteracji  
  - Specyfikacja dodatkowa  
  - Plan zarządzania ryzykiem  

## 3. Zbieranie Wymagań (Requirements)
### 3.1 FURPS+  
- **Obszary wymagań**:  
  | Kategoria          | Opis                                  |  
  |--------------------|---------------------------------------|  
  | Functional         | Funkcjonalności, bezpieczeństwo       |  
  | Usability          | Ergonomia, dokumentacja               |  
  | Reliability        | Odporność na awarie                   |  
  | Performance        | Wydajność, dostępność                 |  
  | Supportability     | Utrzymanie, konfiguracja              |  
  | Design             | Ograniczenia projektowe               |  
  | Implementation     | Narzędzia, standardy                  |  

- **Typowe problemy**:  
  1. Brak priorytetyzacji wymagań.  
  2. Wymagania niemierzalne lub niejasne.  
  3. Przykłady wymagań prawnych: RODO, WCAG 2.0.  

### 3.2 S.M.A.R.T.  
- **Kryteria oceny wymagań**:  
  - **S**zczegółowy  
  - **M**ierzalny  
  - **A**trakcyjny (osiągalny)  
  - **R**ealistyczny  
  - **T**erminowy  

**Przykład wymagania SMART**:  
> Średni czas odpowiedzi przy transakcjach bez zapisu nie może przekraczać **5 sekund**.  

---

## 4. Przypadki Użycia (Use Cases)
- **Definicja**: Sekwencja kroków opisująca interakcję między aktorem a systemem.  
- **Rodzaje dokumentacji**:  
  - **Nieformalna (brief)**: Krótki opis głównego scenariusza sukcesu.  
  - **Pełna (fully dressed)**: Wszystkie kroki, warianty, warunki początkowe/końcowe.  

### Przykład w Gherkin (Cucumber):  
```gherkin
Feature: Zarządzanie kontrahentami  
  Scenario: Dodawanie kontrahenta  
    Given: Jestem zalogowany jako ADMIN  
    When: Dodaję kontrahenta z poprawnymi danymi  
    Then: System rejestruje kontrahenta  
```




## Wykład 2 - UML
<!-- again - aiaiai -->
## 1. Wprowadzenie do UML
- **Rodzaje diagramów**:  
  - **Strukturalne** (np. diagram klas, komponentów) – dokumentują statyczne elementy systemu.  
  - **Behawioralne** (np. diagram sekwencji, stanów) – dokumentują dynamikę systemu.  
- **Narzędzia**:  
  - draw.io, yuml.me (lekkie), Enterprise Architect, Visual Paradigm (zaawansowane).  

---

## 2. Diagramy Klas (Class Diagram)
### 2.1 Hierarchia modeli  
| Typ modelu          | Opis                                                                 | Przykłady elementów                     |  
|---------------------|----------------------------------------------------------------------|-----------------------------------------|  
| **Pojęciowy**       | Reprezentuje pojęcia i relacje w dziedzinie.                        | Pojęcia, asocjacje (bez metod).         |  
| **Obiektowy**       | Refaktoryzacja modelu pojęciowego na klasy obiektowe.               | Klasy, metody, relacje (agregacja, dziedziczenie). |  
| **Relacyjny**       | Mapowanie klas na tabele w bazie danych.                            | Tabele, klucze obce, strategie mapowania dziedziczenia. |  

### 2.2 Strategie mapowania dziedziczenia na tabele  
| Strategia               | Opis                                                                 | Przykład                                |  
|-------------------------|----------------------------------------------------------------------|-----------------------------------------|  
| **Table per concrete**  | Każda klasa potomna ma własną tabelę.                               | `Footballer`, `Cricketer` – osobne tabele. |  
| **Table per hierarchy** | Wszystkie klasy w jednej tabelze z kolumną dyskryminującą.          | Kolumna `type` w tabeli `Players`.      |  
| **Table per type**      | Tabela dla klasy bazowej + tabele dla klas potomnych z relacjami.   | Tabela `Players` + `Footballers`, `Cricketers`. |  

### 2.3 Kluczowe pojęcia  
- **Agregacja vs kompozycja**:  
  - **Agregacja** (pusta kreska): Część może istnieć niezależnie od całości.  
  - **Kompozycja** (wypełniony romb): Część jest ściśle powiązana z całością (np. cykl życia).  
- **Liczebność**: `1`, `*`, `0..1`, `1..*`.  
- **Klasa asocjacyjna**: Używana do modelowania relacji wiele-wiele z dodatkowymi atrybutami.  

---

## 3. Diagramy Obiektów (Object Diagram)
- **Cel**: Migawka stanu systemu w konkretnym momencie.  
- **Elementy**: Instancje klas (obiekty) z wartościami atrybutów i powiązaniami.  
- **Przykład**:  
  ```plaintext
  obiekt1: Osoba
    imię = "Jan"
    nazwisko = "Kowalski"
  obiekt2: Samochód
    model = "Tesla"
  obiekt1 -- obiekt2 : posiada
  ```




## Wykład 3 - SOLID GRASP
## 1. Responsibility-Driven Development (RDD)
Projektowanie obiektowe polega na przypisaniu odpowiedzialności klasom i określeniu ich relacji. Skrajności:
- **Jedna ogromna klasa** – wszystko w jednej strukturze.
- **Bardzo dużo klas, każda z jedną metodą** – nadmierna fragmentacja.

## 2. GRASP (General Responsibility Assignment Software Patterns)
Zbiór dobrych praktyk dotyczących podziału odpowiedzialności:  
1. **Creator** – klasa B tworzy instancje A, jeśli je zawiera, przechowuje lub używa.  
2. **Information Expert** – klasa posiadająca niezbędne dane powinna realizować operację.  
3. **Controller** – odbiera żądania systemowe (np. `Handler`, `Controller`).  
4. **Low Coupling** – minimalizacja powiązań między klasami.  
5. **High Cohesion** – każda klasa powinna mieć jedno, dobrze określone zadanie.  
6. **Polymorphism** – eliminacja instrukcji `if` zależnych od typu poprzez polimorfizm.  
7. **Indirection** – dodatkowa warstwa pośrednicząca dla zmniejszenia sprzężenia.  
8. **Pure Fabrication** – sztuczne klasy pomocnicze poprawiające strukturę (np. `Repository`).  
9. **Protected Variations (Law of Demeter)** – interfejsy stabilizujące punkty zmienności.

## 3. SOLID – Pięć kluczowych zasad obiektowych
1. **SRP (Single Responsibility Principle)** – klasa powinna mieć jedną odpowiedzialność.  
2. **OCP (Open-Closed Principle)** – kod powinien być otwarty na rozszerzenia, ale zamknięty na modyfikacje.  
3. **LSP (Liskov Substitution Principle)** – obiekty klasy bazowej powinny być zastępowalne przez klasy pochodne bez zmiany zachowania.  
4. **ISP (Interface Segregation Principle)** – interfejsy powinny być podzielone na mniejsze, aby klasy nie implementowały nieużywanych metod.  
5. **DIP (Dependency Inversion Principle)** – moduły wyższego poziomu powinny zależeć od abstrakcji, a nie implementacji.

## 4. Inne zasady
- **DRY (Don’t Repeat Yourself)** – unikanie powielania kodu.  
- **LoD (Law of Demeter)** – ograniczenie wiedzy klasy o innych klasach.  
- **DMMT (Don’t Make Me Think)** – przejrzystość kodu.  
- **DOP (Don’t Optimize Prematurely)** – unikanie przedwczesnej optymalizacji.







